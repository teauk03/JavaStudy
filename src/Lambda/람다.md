# **람다(Lambda)**

---
<br> </br>

## **람다식(Lambda Exression)이란?**
* 함수에 인수로 호출되거나, 전달하는 위치에서 익명 함수 개체를 편리하게 정의하는 방법
* 특정 클래스에 반드시 속해야하는 메서드와는 다르게 람다식은 그 메서드가 독립적인 기능을 함

<br></br>

**인터페이스를 구현한 클래스를 만들어 객체 생성**
```java
  public interface  A {
    // 추상 메서드 b();
    void b(); 
  }
```
```java
  public class A1 implements A {
    // A1 클래스에서 b(); 메서드 정의
    @Override
   public void b(){
       System.out.println("인테페이스를 구현한 클래스 A1의 객체");
   }
  }
```
```java
  public class TestPrintA {
    public static void main(String[] args) {
        // 인터페이스 A타입의 참조 변수 a1에 A1 객체를 할당
        A a1 = new A1();
        a1.b(); // output: 인테페이스를 구현한 클래스 A1의 객체
    }
  }
```
<br></br>

**익명 내부 클래스를 통해 객체 생성**
```java
  public class TestPrintA {
    public static void main(String[] args) {
        // 익명 내부 클래스를 사용한 객체 생성
        A a2 = new A(){
            @Override
            public void b() {
                System.out.println("내부 익명 클래스로 생성된 객체 a2");
            }
        };
        a2.b(); //output: 내부 익명 클래스로 생성된 객체 a2
        
        
        
        // 람다식을 사용한 객체 생성 (함수형 인터페이스 조건 O)
        A a3 = () -> System.out.println("람다식을 활용한 객체");
        a3.b(); //output: 람다식을 활용한 객체
    }
  }
```

### **람다식을 사용하기 위한 조건**

---
1. 하나의 추상 메서드를 가진 함수형 인터페이스가 있어야 함
   * 해당 함수형 인터페이스와 추상 메서드를 구현하는 형태로 사용함
2. Java가 람다식의 타겟 타입을 추론할 수 있어야함
3. Java의 기본 함수형 인터페이스를 활용하거나 직접 선언함

<br></br>

### **람다식의 형태**

---
**기존 메서드의 형식**
```java
반환타입 메서드이름(매개변수) {
//코드 블럭
}
```
**람다식의 형식**
```java
(매개변수) -> {
// 코드 블럭
}
```
1. 매개변수
   * 없음: ()
   * 1개: (x), x
   * 여러개: (x,y,z....)
2. 코드블록
   * 단일 표현식일 경우 {}  생략
   * 다중 표현식일 경우 {} 생략 불가, return
3. 타입
   * 컴파일러가 추론이 가능하면 생략
   * 필요하면 명시 (int x, String y)


## **함수형 인터페이스(Functional Interface)**

---
### **함수형 인터페이스란?** 
* 추상 메서드가 하나만 존재하는 인터페이스
* java에서 람다식을 다루기 위한 인터페이스라고도 부름
* 인터페이스에 `@FunctionalInterface` 어노테이션을 붙여서 함수형 인터페이스임을 명시함
  * 컴파일러가 이 인터페이스를 읽을 때 추상 메서드가 하나인지 검증함
* static 메서드와 default 메서드의 갯수에는 제약이 없음
* 람다식은 이 함수형 인터페이스의 단일 추상 메서드를 구현하는 방식임
* 람다식 = 익명 클래스의 객체

### **람다식의 타입과 형변환**
* `람다식 타입 != 함수형 인터페이스 타입`
* 람다식도 익명 객체이므로 타입을 컴파일러가 임의로 정해줌
* 대입 연산자를 사용해서 양변의 타입을 일치 시키기 위해선 형 변환 작업이 필요로 함
* <U>람다식은 함수형 인터페이스 타입으로만 형변환이 가능</U>

```java
@FunctionalInterface
interface MyFcn{
   void myMethode();
}

class {
        MyFcn f = ()-> {}; // MyFcn f = (Myfnc)(()->{});
        Object obj = (MyFcn) (()->{});
        String str = ((Object) (MyFcn)(()->{})).toString();
        
        Object obj = (Object) (()->{}); // 에러 : 호환되지 않는 유형: 람다 표현식의 호환되지 않는 매개변수 유형

        }
```

### **java.util.function 패키지**
* 일반적으로 자주 쓰이는 형식의 메서드를 미리 함수형 인터페이스로 정의한 패키지
* 함수형 인터페이스에 정의된 메서드 이름의 통일로 재사용성, 유지보수 측면에서 유리함
* 함수형 인터페이스는 단 하나의 추상 메서드를 가짐 (람다식이나 메서드 참조로 구현)

| 함수형 인터페이스            | 메서드                 | Note                                   |
|----------------------|---------------------|----------------------------------------|
| `java.lang.Runnable` | `void run()`        | 매개변수x, 반환값x                            |
| `Supplier<T>`        | `T get()`           | 매개변수x, 반환값o                            |
| `Consumer<T>`        | `void accept(T t)`  | Supplier와 반대 (매개변수o, 반환값x)             |
| `Function<T,R>`      | `R apply(T t)`      | 일반적인 함수(매개변수를 받아서 결과를 반환)              |
| `Predicate<T>`       | `boolean test(T t)` | 조건식을 표현하는데 사용. 매개변수는 1개, 반환타입은 boolean |

![java.util.function_note1.png](..%2F%EC%84%A4%EB%AA%85%EC%82%AC%EC%A7%84%2Fjava.util.function_note1.png)

<br> </br>

#### **매개변수가 2개인 함수형 인터페이스**
* 이름 앞에 `Bi`를 붙임

| 함수형 인터페이스            | 메서드                      | Note                                   |
|----------------------|--------------------------|----------------------------------------|
| `BiConsumer<T,U>`    | `void accept(T t, U u)`  | 2개매개변수o, 반환값x                          |
| `BiFunction<T,U>`    | `R apply(T t, U u)`      | 2개의 매개변수를 받아서 하나의 결과를 반환               |
| `BiPredicate<T,U,R>` | `boolean test(T t, U u)` | 조건식을 표현하는데 사용. 매개변수는 2개, 반환타입은 boolean |

![java.util.function_note2.png](..%2F%EC%84%A4%EB%AA%85%EC%82%AC%EC%A7%84%2Fjava.util.function_note2.png)
* 2개 이상 매개변수를 받는 함수형 인터페이스가 필요하면 직접 만들어서 사용
```java
@FunctionalInterface
interface TriFunction<T,U,V,R> {
    R apply(T t,U u,V v,R r);
}
```
<br> </br>

#### **UnaryOperator와 BinaryOperator**
* `java.util.function` 패키지에서 제공되는 함수형 인터페이스
* `Function 인터페이스`를 확장한 형태로 구현
  * 매개변수와 반환 값의 타입이 동일한 것만 빼면 `Function 인터페이스`와 동일함
* 특정한 연산을 수행하기 위해 만들어짐

| 함수형 인터페이스        | 메서드                              | Note                                                        |
|-----------------------|------------------------------------|------------------------------------------------------------|
| `UnaryOperator<T>`    | `T apply(T t)`                     | 하나의 입력값을 받아 같은 타입의 값을 반환. `Function<T, T>`의 특수화 |
| `BinaryOperator<T>`   | `T apply(T t1, T t2)`              | 두 개의 입력값을 받아 같은 타입의 값을 반환. `BiFunction<T, T, T>`의 특수화 |


#### **기본형 함수형 인터페이스**
* 자바의 기본형을 처이하기 위해 제공된 함수형 인터페이스
* 성능 최적화를 위해 만들어짐
* Boxing과 UnBoxing으로 인한 성능 문제를 줄이기 위함
* `java.util.function` 패키지에 정의 되어 있음

| **범주**       | **인터페이스**           | **형식**                           | **메서드**                             | **설명**                               |
|--------------|--------------------------|-------------------------------------|----------------------------------------|----------------------------------------|
| **Supplier** | `IntSupplier`           | `() -> int`                        | `int getAsInt()`                       | 기본형 `int` 값을 생성하는 함수형 인터페이스. |
|              | `LongSupplier`          | `() -> long`                       | `long getAsLong()`                     | 기본형 `long` 값을 생성하는 함수형 인터페이스. |
|              | `DoubleSupplier`        | `() -> double`                     | `double getAsDouble()`                 | 기본형 `double` 값을 생성하는 함수형 인터페이스. |
| **Consumer** | `IntConsumer`           | `(int) -> void`                    | `void accept(int value)`               | 기본형 `int` 값을 소비(처리)하는 함수형 인터페이스. |
|              | `LongConsumer`          | `(long) -> void`                   | `void accept(long value)`              | 기본형 `long` 값을 소비(처리)하는 함수형 인터페이스. |
|              | `DoubleConsumer`        | `(double) -> void`                 | `void accept(double value)`            | 기본형 `double` 값을 소비(처리)하는 함수형 인터페이스. |
| **Predicate** | `IntPredicate`          | `(int) -> boolean`                 | `boolean test(int value)`              | 기본형 `int` 값에 대해 조건을 테스트하는 함수형 인터페이스. |
|              | `LongPredicate`         | `(long) -> boolean`                | `boolean test(long value)`             | 기본형 `long` 값에 대해 조건을 테스트하는 함수형 인터페이스. |
|              | `DoublePredicate`       | `(double) -> boolean`              | `boolean test(double value)`           | 기본형 `double` 값에 대해 조건을 테스트하는 함수형 인터페이스. |
| **UnaryOperator** | `IntUnaryOperator`      | `(int) -> int`                     | `int applyAsInt(int operand)`          | 기본형 `int` 값을 받아서 동일한 `int` 값을 반환하는 함수형 인터페이스. |
|              | `LongUnaryOperator`     | `(long) -> long`                   | `long applyAsLong(long operand)`       | 기본형 `long` 값을 받아서 동일한 `long` 값을 반환하는 함수형 인터페이스. |
|              | `DoubleUnaryOperator`   | `(double) -> double`               | `double applyAsDouble(double operand)` | 기본형 `double` 값을 받아서 동일한 `double` 값을 반환하는 함수형 인터페이스. |
| **BinaryOperator**| `IntBinaryOperator`     | `(int, int) -> int`                | `int applyAsInt(int left, int right)`  | 기본형 `int` 두 개를 받아 동일한 `int` 값을 반환하는 함수형 인터페이스. |
|              | `LongBinaryOperator`    | `(long, long) -> long`             | `long applyAsLong(long left, long right)`| 기본형 `long` 두 개를 받아 동일한 `long` 값을 반환하는 함수형 인터페이스. |
|              | `DoubleBinaryOperator`  | `(double, double) -> double`       | `double applyAsDouble(double left, double right)`| 기본형 `double` 두 개를 받아 동일한 `double` 값을 반환하는 함수형 인터페이스. |
| **To(타입)Function** | `ToIntFunction<T>`      | `(T) -> int`                       | `int applyAsInt(T value)`              | 참조형 `T` 값을 받아 `int`로 변환하는 함수형 인터페이스. |
|              | `ToLongFunction<T>`     | `(T) -> long`                      | `long applyAsLong(T value)`            | 참조형 `T` 값을 받아 `long`으로 변환하는 함수형 인터페이스. |
|              | `ToDoubleFunction<T>`   | `(T) -> double`                    | `double applyAsDouble(T value)`        | 참조형 `T` 값을 받아 `double`로 변환하는 함수형 인터페이스. |
| **(타입)To(타입)Function** | `IntToLongFunction`   | `(int) -> long`                    | `long applyAsLong(int value)`          | `int` 값을 받아 `long`으로 변환하는 함수형 인터페이스. |
|              | `IntToDoubleFunction`   | `(int) -> double`                  | `double applyAsDouble(int value)`      | `int` 값을 받아 `double`으로 변환하는 함수형 인터페이스. |
|              | `LongToIntFunction`     | `(long) -> int`                    | `int applyAsInt(long value)`           | `long` 값을 받아 `int`로 변환하는 함수형 인터페이스. |
|              | `LongToDoubleFunction`  | `(long) -> double`                 | `double applyAsDouble(long value)`     | `long` 값을 받아 `double`으로 변환하는 함수형 인터페이스. |
|              | `DoubleToIntFunction`   | `(double) -> int`                  | `int applyAsInt(double value)`         | `double` 값을 받아 `int`로 변환하는 함수형 인터페이스. |
|              | `DoubleToLongFunction`  | `(double) -> long`                 | `long applyAsLong(double value)`       | `double` 값을 받아 `long`으로 변환하는 함수형 인터페이스. |
| **Obj(타입)Consumer** | `ObjIntConsumer<T>`     | `(T, int) -> void`                 | `void accept(T obj, int value)`        | 참조형 `T` 객체와 `int` 값을 처리하는 함수형 인터페이스. |
|              | `ObjLongConsumer<T>`    | `(T, long) -> void`                | `void accept(T obj, long value)`       | 참조형 `T` 객체와 `long` 값을 처리하는 함수형 인터페이스. |
|              | `ObjDoubleConsumer<T>`  | `(T, double) -> void`              | `void accept(T obj, double value)`     | 참조형 `T` 객체와 `double` 값을 처리하는 함수형 인터페이스. |


## **함수 합성(Function Synthesis)**

---

* 두개 이상의 함수를 결합하여 하나의 함수를 생성하는 프로그래밍 기법
* 합성된 함수는 이전 함수의 출력 값을 다음 함수의 입력 값으로 사용하는 구조를 사용함

### **Function 합성**
* java.util.functuion 패키지에 default, static 메서드가 정의 되어 있음
* 두 람다를 하나의 람다식을 만들 수 있음
* 어떤 식을 적용하냐에 따라 값이 달라짐
```java
default <V> Function<T,V> andThen(Function<? super R, ? extends R> after)
default <V> Function<T,V> compose(Function<? super V, ? extends T> before)
static <T> Fuctuion<T,T> identity()
```
* **andThen() 메서드**
  * 첫 번째 함수의 결과 값을 두 번째 함수의 입력 값으로 입력하게 함
  * ```java
    Function<String, Integer> f = (s)->Integer.parseInt(s, 16); // 문자열을 숫자로 변환하는 f 함수
    Function<Integer, String> g = (i)->Integer.toBinaryString(i); // 숫자를 2진 문자열로 변환하는 g 함수
    
    Function<String, String> h1 = f.andThen(g); // h1함수: 문자를 입력 받음(T: String) -> 문자열을 숫자로 변환 -> 변환된 숫자를 2진 문자열로 변환
    ```
    ![andThen_설명 사진.png](..%2F%EC%84%A4%EB%AA%85%EC%82%AC%EC%A7%84%2FandThen_%EC%84%A4%EB%AA%85%20%EC%82%AC%EC%A7%84.png)

* **compose() 메서드**    
    * 두 번째 함수의 결과 값을 첫 번째 함수의 입력 값으로 입력하게 함
    * ```java
      Function<String, Integer> f = (s)->Integer.parseInt(s, 16); // 문자열을 숫자로 변환하는 f 함수
      Function<Integer, String> g = (i)->Integer.toBinaryString(i); // 숫자를 2진 문자열로 변환하는 g 함수

      Function<Integer, Integer> h2 = f.compose(g); // h2함수: 숫자를 입력 받음(T:Integer) -> 숫자를 2진 문자열로 변환 -> 변환된 2진 문자열을 숫자로 변환
      ```
      ![compose_설명사진.png](..%2F%EC%84%A4%EB%AA%85%EC%82%AC%EC%A7%84%2Fcompose_%EC%84%A4%EB%AA%85%EC%82%AC%EC%A7%84.png)